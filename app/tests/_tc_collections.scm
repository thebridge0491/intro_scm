(check-set-mode! 'report-failed) ; 'off, 'summary, 'report-failed, 'report

(define (setUpClass) 
    (display (format "~a~%" "SetUpClass ...")))

(define (tearDownClass) 
    (display (format "~a~%" "... TearDownClass")))

(define (setUp) 
    (display (format "~a~%" "SetUp ...")))

(define (tearDown) 
    (display (format "~a~%" "... TearDown")))

(define epsilon 0.001)

(define (wrap_test start end test_fun)
    (start)
    (test_fun)
    (end))            

(define (suite)
    ;(display (format "~a~%-----~a~%" (make-string 40 #\-) (current-module)))
    (display (format "~a~%-----~a~%" (make-string 40 #\-) mod-sym))
    
    (wrap_test setUp tearDown (lambda ()
        (let ((lst (list 2 1 0 4 3)))
        	(check (list 1) => '(1))
        	(check lst => '(2 1 0 4 3))
        	(check (list= = '() '(0 1 2)) => #f)
        	(check (null? '()) => #t)
        	(check (car lst) => 2)
        	(check (list-ref lst 2) => 0)
        	(check (length lst) => 5)
        	(check (append lst '(9 9 9 9)) => '(2 1 0 4 3 9 9 9 9))
        	(check (reverse lst) => '(3 4 0 1 2))
        	(check (equal? (member 4 lst) #f) => #f)
        	(check (any odd? lst) => #t)
        	(check (every even? lst) => #f)
        	(check (filter even? lst) => '(2 0 4))
        	(check (remove even? lst) => '(1 3))
        	(check (fold (lambda (el acc) (- acc el)) 0 lst) => -10)
        	(check (fold-right (lambda (el acc) (- el acc)) 0 lst) => 0)
        	(check (map (lambda (el) (+ el 2)) lst) => '(4 3 2 6 5))
        	(check (equal? (apply array (shape 0 1 0 (length lst)) lst)
                (array (shape 0 1 0 (length lst)) 2 1 0 4 3)) => #t)
            (check (list->vector lst) => #(2 1 0 4 3))
        	(cond-expand
				((library (srfi 95)) (check (sort lst >) => '(4 3 2 1 0)))
				(else))
        )))
    
    (wrap_test setUp tearDown (lambda ()
        (let ((vec (vector 2 1 0 4 3)))
        	(check (vector 1) => #(1))
        	(check vec => #(2 1 0 4 3))
        	(check (vector= = #() #(0 1 2)) => #f)
        	(check (vector-empty? #()) => #t)
        	(check (vector-ref vec 2) => 0)
        	(check (vector-length vec) => 5)
        	(check (vector-append vec #(9 9 9 9)) => #(2 1 0 4 3 9 9 9 9))
        	(check (vector-fold (lambda (idx acc el) (- acc el)) 0 vec) => -10)
        	(check (vector-map (lambda (idx el) (+ el 2)) vec) => #(4 3 2 6 5))
        	(check (vector->list vec) => '(2 1 0 4 3))
        	(vector-set! vec 0 7)
        	(check (vector= = vec #(7 1 0 4 3)) => #t)
        )))
    
    (wrap_test setUp tearDown (lambda ()
        (let* ((vec #(0 1 2 3 4 5)) (nlst '((0 1 2) (3 4 5)))
        		(arr0 (make-array (shape 0 2 0 3) 0))
                (arr2d (apply array (shape 0 2 0 3) '(0 1 2 3 4 5)))
                (dimx_arr (array-rank arr2d))
                (dimy_arr (+ 1 (- (array-end arr2d 0) (array-start arr2d 0)))))
        	(check (equal? arr2d (apply array (shape 0 2 0 3) 
				(concatenate nlst))) => #t)
        	(check (array-ref arr2d 0 2) => 2)
        	(for-each (lambda (row)
        		(for-each (lambda (col)
        			(array-set! arr0 row col (vector-ref vec 
                    (+ (* row dimy_arr) col))))
        			(iota dimy_arr)))
        		(iota dimx_arr))
            (check (equal? arr2d arr0) => #t)
            (check (equal? arr2d (apply array (shape 0 2 0 3) 
				(vector->list vec))) => #t)
            (check (equal? arr2d (array (shape 0 2 0 3) 0 1 2 3 4 5)) => #t)
        )))
    
    (wrap_test setUp tearDown (lambda ()
        (let* ((lst (list #\a #\e #\k #\p #\u #\k #\a))
        		(alst (fold-right alist-cons '() (map (lambda (el)
        			(format "'ltr ~a'" el)) (iota (length lst))) lst)))
        	(check (alist-cons "init" #\i '()) => '(("init" . #\i)))
        	(check (not (assoc "'ltr 1'" alst)) => #f)
        	(check (assoc "'ltr 1'" (alist-delete "'ltr 1'" alst)) => #f)
        	(cond-expand
				((library (srfi 95))
					(check (equal?
						(sort (hash-table->alist (alist->hash-table alst)) 
							(lambda (a b) (string<? (car a) (car b)))) alst)
						=> #t))
        		(else
					(check (fold (lambda (el acc) (and acc (any (lambda (e) 
						(equal? e el)) (hash-table->alist
							(alist->hash-table alst))))) #t alst) => #t)
					))
        )))
    
    (wrap_test setUp tearDown (lambda ()
        (let* ((lst (list #\a #\e #\k #\p #\u #\k #\a))
        		(set (fold-right (lambda (el acc)
        			(lset-adjoin char=? acc el)) '() lst))
        		(set2 '(#\q #\p #\z #\u)))
        	(check (lset-adjoin char=? '() #\i) => '(#\i))
        	(cond-expand
				((library (srfi 95))
					(check (sort (lset-union char=? set set2) char<?) =>
						'(#\a #\e #\k #\p #\q #\u #\z))
					(check (sort (lset-intersection char=? set set2) char<?)
						=> '(#\p #\u))
					(check (sort (lset-difference char=? set set2) char<?)
						=> '(#\a #\e #\k))
					(check (sort (lset-xor char=? set set2) char<?) =>
						'(#\a #\e #\k #\q #\z)))
				(else
					(check (fold (lambda (el acc) (and acc (any (lambda (e) 
						(equal? e el)) (lset-union char=? set set2))))
						#t '(#\a #\e #\k #\p #\q #\u #\z)) => #t)
					(check (fold (lambda (el acc) (and acc (any (lambda (e) 
						(equal? e el)) (lset-intersection char=? set set2))))
						#t '(#\p #\u)) => #t)
					(check (fold (lambda (el acc) (and acc (any (lambda (e) 
						(equal? e el)) (lset-difference char=? set set2))))
						#t '(#\a #\e #\k)) => #t)
					(check (fold (lambda (el acc) (and acc (any (lambda (e) 
						(equal? e el)) (lset-xor char=? set set2))))
						#t '(#\a #\e #\k #\q #\z)) => #t)
					))
        )))
    
    (wrap_test setUp tearDown (lambda ()
        (let* ((lst (list #\a #\e #\k #\p #\u #\k #\a))
        		(alst (fold-right alist-cons '() (map (lambda (el)
        			(format "'ltr ~a'" el)) (iota (length lst))) lst))
        		(htbl (alist->hash-table alst))
        		(htbl0 (make-hash-table)))
        	(for-each (lambda (tup1) 
                (hash-table-set! htbl0 (car tup1) (cdr tup1))) alst)
        	(check (hash-table? (make-hash-table)) => #t)
        	(check (= (hash-table-size htbl0) (hash-table-size htbl)) => #t)
        	(hash-table-walk htbl0 (lambda (key val)
        		(check (hash-table-ref htbl key #\Z) => val)))
        	(check (hash-table-size htbl) => (length lst))
        	(check (hash-table-ref htbl "'ltr 1'" #f) => #\e)
        	(check (hash-table-exists? htbl "'ltr 1'") => #t)
        	(cond-expand
				((library (srfi 95))
					(check (equal? (sort (hash-table->alist htbl) (lambda (a b)
						(string<? (car a) (car b)))) alst) => #t))
				(else
					(check (fold (lambda (el acc) (and acc (any (lambda (e) 
						(equal? e el)) (hash-table->alist htbl))))
						#t alst) => #t)
					))
        	
        	(hash-table-delete! htbl "'ltr 0'")
        	(check (hash-table-exists? htbl "'ltr 0'") => #f)
        	(hash-table-set! htbl "'ltr 0'" #\M)
        	(check (hash-table-ref htbl "'ltr 0'" #f) => #\M)
        )))
    
    (wrap_test setUp tearDown (lambda ()
        (let ((lst (list 25.7 0.1 78.5 52.3)) (queue (make-queue)))
            (for-each (lambda (el) (enqueue! queue el)) lst)
            (check (queue? queue) => #t)
            (check (queue-empty? queue) => #f)
            (check (queue-front queue) => 25.7)
            (check (queue-rear queue) => 52.3)
            
            (enqueue! queue -5.0)
            (check (queue-rear queue) => -5.0)
            (queue-push! queue 0.345)
            (check (queue-front queue) => 0.345)
            (dequeue! queue)
            (check (= 0.345 (queue-front queue)) => #f)
        )))
    
    (wrap_test setUp tearDown (lambda ()
        (cond-expand
            (gauche
        (let ((lst (list 25.7 0.1 78.5 52.3)) (heap_max (make-binary-heap))
                (heap_min (make-binary-heap)))
            (check (binary-heap-num-entries (make-binary-heap)) => 0)
            (for-each (lambda (el) (binary-heap-push! heap_max el)
                (binary-heap-push! heap_min el)) lst)
            (check (binary-heap-num-entries heap_max) => (length lst))
            
            (binary-heap-push! heap_max 100.0)
            (check (binary-heap-pop-max! heap_max) => 100.0)
            (binary-heap-push! heap_min -5.0)
            (check (binary-heap-pop-min! heap_min) => -5.0)
        ))
          (sagittarius
        (let ((lst (list 25.7 0.1 78.5 52.3)) (heap_min (make-heap compare))
                (heap_max (make-heap (lambda (a b) (compare b a)))))
            (check (heap-size (make-heap compare)) => 0)
            (for-each (lambda (el) (heap-set! heap_max el el)
                (heap-set! heap_min el el)) lst)
            (check (heap-size heap_max) => (length lst))
            
            (heap-set! heap_max 100.0 100.0)
            (check (heap-entry-value (heap-extract-min! heap_max)) => 100.0)
            (heap-set! heap_min -5.0 -5.0)
            (check (heap-entry-value (heap-extract-min! heap_min)) => -5.0)
        ))
            (else))
        ))
    
    
    (check-report)
    )
