(check-set-mode! 'report-failed) ; 'off, 'summary, 'report-failed, 'report

(define (setUpClass) 
    (display (format "~a~%" "SetUpClass ...")))

(define (tearDownClass) 
    (display (format "~a~%" "... TearDownClass")))

(define (setUp) 
    (display (format "~a~%" "SetUp ...")))

(define (tearDown) 
    (display (format "~a~%" "... TearDown")))

(define epsilon 0.001)

(define (wrap_test start end test_fun)
    (start)
    (test_fun)
    (end))            

(define (suite)
    (let ((lst (iota 5)) (revlst (reverse (iota 5))))
    ;(display (format "~a~%-----~a~%" (make-string 40 #\-) (current-module)))
    (display (format "~a~%-----~a~%" (make-string 40 #\-) mod-sym))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (cnt)
        (let* ((proc1 (lambda (e) (quotient 32 (expt 2 e))))
                (ans_id (reverse (fold (lambda (e a)
                    (cons e a)) '() (iota cnt))))
                (ans1 (reverse (fold (lambda (e a)
                    (cons (proc1 e) a)) '() (iota cnt)))))
            (for-each (lambda (fn1)
                (check (fn1 (lambda (e) e) cnt) => ans_id)
                (check (fn1 proc1 cnt) => ans1))
                (list tabulate_i tabulate_r tabulate_do)))
        ) (list 0 5 10))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (n)
        (let* ((xs (iota n)) (ans (length xs)))
            (for-each (lambda (fn1) (check (fn1 xs) => ans))
                (list length_i length_r length_do)))
        ) (list 0 3 5 7))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((ans (list-ref l 3)))
            (for-each (lambda (fn1) (check (fn1 3 l) => ans))
                (list nth_i nth_r nth_do)))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((pred (lambda (el) (= el 3))) (ans (list-index pred l)))
            (for-each (lambda (fn1) (check (fn1 pred l) => ans))
                (list index_i index_do)))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((pred (lambda (e) (= e 3))) (ans (find pred l)))
            (for-each (lambda (fn1) (check (fn1 pred l) => ans))
                (list find_i find_r find_do)))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((ans_min (apply min l)) (ans_max (apply max l)))
            (for-each (lambda (fn_tup)
                (let ((fn_min (car fn_tup)) (fn_max (cdr fn_tup)))
                    (check (apply fn_min l) => ans_min)
                    (check (apply fn_max l) => ans_max)))
                (list (cons min_i max_i) (cons min_r max_r)
                    (cons min_do max_do))))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((ans (reverse l)))
            (for-each (lambda (fn1) (check (fn1 l) => ans))
                (list reverse_i reverse_r reverse_do)))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((ans (list-copy l)))
            (for-each (lambda (fn1) (check (fn1 l) => ans))
                (list copy_i copy_r copy_do)))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((ans_take (take l 3)) (ans_drop (drop l 3)))
            (for-each (lambda (fn_tup)
                (let ((fn_take (car fn_tup)) (fn_drop (cdr fn_tup)))
                    (check (fn_take 3 l) => ans_take)
                    (check (fn_drop 3 l) => ans_drop)))
                (list (cons take_i drop_i) (cons take_do drop_do))))
        (let* ((ans (receive (t d) (split-at l 3) (list t d))))
            (for-each (lambda (fn1)
                    (check (receive (t d) (fn1 3 l) (list t d)) => ans))
                (list split-at_i split-at_do)))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (fn_tup)
        (let ((fn_any (car fn_tup)) (fn_every (cdr fn_tup)))
            (check (fn_any integer? '(1 2 #\a)) => (any integer? '(1 2 #\a)))
            (check (fn_any null? '((1) (2 3) ())) =>
                (any null? '((1) (2 3) ())))
            (check (fn_every integer? '(1 2)) => (every integer? '(1 2)))
            (check (fn_every pair? '((1) (#\a))) =>
                (every pair? '((1) (#\a))))
            )
        ) (list (cons any_i every_i) (cons any_r every_r)
            (cons any_do every_do)))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((proc (lambda (el) (+ el 2))) (ans (map proc l)))
            (for-each (lambda (fn1) (check (fn1 proc l) => ans))
                (list map_i map_r map_do)))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((proc (lambda (el) (display (format "~a " el))))
                (ans (for-each proc l)))
            (for-each (lambda (fn1) (check (fn1 proc l) => ans))
                (list for-each_i for-each_r for-each_do)))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((pred even?)
                (ans_filter (filter pred l)) (ans_remove (remove pred l)))
            (for-each (lambda (fn_tup)
                (let ((fn_filter (car fn_tup)) (fn_remove (cdr fn_tup)))
                    (check (fn_filter pred l) => ans_filter)
                    (check (fn_remove pred l) => ans_remove)))
                (list (cons filter_i remove_i) (cons filter_r remove_r)
                    (cons filter_do remove_do))))
        (let* ((pred even?)
                (ans (receive (f r) (partition pred l) (list f r))))
            (for-each (lambda (fn1)
                    (check (receive (f r) (fn1 pred l) (list f r)) => ans))
                (list partition_i partition_r partition_do)))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((corp1 (lambda (e a) (+ a e))) (corp2 (lambda (e a) (- a e)))
                (ans1 (fold corp1 0 l)) (ans2 (fold corp2 0 l)))
            (for-each (lambda (fn1)
                (check (fn1 corp1 0 l) => ans1)
                (check (fn1 corp2 0 l) => ans2))
                (list fold-left_i fold-left_r fold-left_do)))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((proc1 (lambda (e a) (+ e a))) (proc2 (lambda (e a) (- e a)))
                (ans1 (fold-right proc1 0 l)) (ans2 (fold-right proc2 0 l)))
            (for-each (lambda (fn1)
                (check (fn1 proc1 0 l) => ans1)
                (check (fn1 proc2 0 l) => ans2))
                (list fold-right_i fold-right_r fold-right_do)))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda ()
        (let* ((seed1 '(0 . 10)) (pred1 (lambda (tup) (= (cdr tup) 0)))
                (func1 (lambda (tup) (car tup))) (gen1 (lambda (tup)
                    (cons (+ (car tup) 1) (- (cdr tup) (car tup)))))
                (seed2 '(0 . -10)) (gen2 (lambda (tup)
                    (cons (+ (car tup) 1) (+ (cdr tup) (car tup)))))
                (ans1 (unfold-right pred1 func1 gen1 seed1))
                (ans2 (unfold-right pred1 func1 gen2 seed2)))
            (for-each (lambda (fn1)
                (check (fn1 pred1 func1 gen1 seed1) => ans1)
                (check (fn1 pred1 func1 gen2 seed2) => ans2))
                (list unfold-right_i unfold-right_do)))
        ))
    
    (wrap_test setUp tearDown (lambda ()
        (let* ((seed1 '(0 . 10)) (pred1 (lambda (tup) (= (cdr tup) 0)))
                (func1 (lambda (tup) (car tup))) (gen1 (lambda (tup)
                    (cons (+ (car tup) 1) (- (cdr tup) (car tup)))))
                (seed2 '(0 . 2)) (gen2 (lambda (tup)
                    (cons (+ (car tup) 1) (- (car tup) (cdr tup)))))
                (ans1 (unfold pred1 func1 gen1 seed1))
                (ans2 (unfold pred1 func1 gen2 seed2)))
            (for-each (lambda (fn1)
                (check (fn1 pred1 func1 gen1 seed1) => ans1)
                (check (fn1 pred1 func1 gen2 seed2) => ans2))
                (list unfold-left_r unfold-left_do)))
        ))

    (cond-expand
		((library (srfi 95))
			(wrap_test setUp tearDown (lambda () (for-each (lambda (l)
				(for-each (lambda (fn1)
					(check (fn1 l <) => (sorted? l <))
					(check (fn1 l >) => (sorted? l >))
					(check (fn1 '((0 . #\a) (1 . #\b) (2 . #\c)) < car) =>
						(sorted? '((0 . #\a) (1 . #\b) (2 . #\c)) < car))
					(check (fn1 '((2 . #\c) (1 . #\b) (0 . #\a)) > car) =>
						(sorted? '((2 . #\c) (1 . #\b) (0 . #\a)) > car)))
					(list is-ordered_i? is-ordered_r? is-ordered_do?))
				) (list lst revlst)))))
        (else))

    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((l2 '(9 9 9 9)) (ans (append l l2)))
            (for-each (lambda (fn1) (check (fn1 l l2) => ans))
                (list append_i append_r append_do)))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda ()
        (let* ((l2 '(9 9 9 9)))
            (for-each (lambda (fn1)
                (check (fn1 lst l2) => '(0 9 1 9 2 9 3 9 4))
                (check (fn1 revlst l2) => '(4 9 3 9 2 9 1 9 0)))
                (list interleave_i interleave_r interleave_do)))
        ))
    
    (wrap_test setUp tearDown (lambda () (for-each (lambda (l)
        (let* ((proc (lambda (e1 e2) (+ e1 e2 2))) (ans (map proc l l)))
            (for-each (lambda (fn1) (check (fn1 proc l l) => ans))
                (list map2_i map2_r map2_do)))
        ) (list lst revlst))))
    
    (wrap_test setUp tearDown (lambda ()
        (for-each (lambda (fn1)
            (check (fn1 '(0 1 2) '(20 30)) => (zip '(0 1 2) '(20 30)))
            (check (fn1 '(0 (1 2)) '(20 30)) => (zip '(0 (1 2)) '(20 30))))
            (list zip_i zip_r zip_do zip_m)))
        )
    
    (wrap_test setUp tearDown (lambda ()
        (let ((lst1 '((0 20) (1 30))) (lst2 '((0 20) (1 30) (#\a #\b)))
                (proc_recv2 (lambda (xs fn)
                    (receive (l1 l2) (fn xs) (list l1 l2)))))
            (for-each (lambda (fn1)
                (check (proc_recv2 lst1 fn1) => (proc_recv2 lst1 unzip2))
                (check (proc_recv2 lst2 fn1) => (proc_recv2 lst2 unzip2)))
                (list unzip_i unzip_do unzip_m)))
        ))
    
    (wrap_test setUp tearDown (lambda ()
        (for-each (lambda (fn1)
            (check (fn1 '((0 1 2) (20 30))) =>
                (concatenate '((0 1 2) (20 30))))
            (check (fn1 '((0 (1 2)) (20 (30)))) =>
                (concatenate '((0 (1 2)) (20 (30))))))
            (list concat_i concat_r concat_do concat_a)))
        )
    
        
    (check-report)
    ))
